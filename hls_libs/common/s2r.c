#include "s2r.h"
#include "util.h"

/* Open S2 surface reflectance hdf for create, read, or write*/
int open_s2r(s2r_t *s2r, intn access_mode)
{
	char sds_name[500];     
	int32 sds_index;
	int32 nattr, attr_index;
	char attr_name[200];
	int32 dimsizes[2];
	int32 rank, data_type, n_attrs;
	int32 count;
	int32 start[2], edge[2];

	int ib;
	int psi;	
	char message[MSGLEN];

	s2r->access_mode = access_mode;
	s2r->sd_id = FAIL;
	for (ib = 0; ib < S2NBAND; ib++) {
		s2r->sds_id_ref[ib] = FAIL;
		s2r->ref[ib] = NULL;
	}
	s2r->sds_id_accloud = FAIL;
	s2r->sds_id_acmask = FAIL;
	s2r->sds_id_fmask = FAIL;
	s2r->accloud = NULL;
	s2r->acmask = NULL;
	s2r->fmask = NULL;

	/* Initialize HDF attributes. But it seems not to help -- if an attribute is
	 * not set, a write still quietly ruins the HDF file.
	 */
	s2r->uri[0] = '0';
	s2r->quality[0] = '\0';	/* Quality flag, from SAFE XML */ 
	s2r->spacecraft[0] = '\0';
	s2r->granuleid[0] = '\0';    /* e.g. 11SKA */
	s2r->tile_id[0] = '\0';
	s2r->datastrip_id[0] = '\0';
	s2r->baseline[0] = '\0'; 	/* processing baseline */
	s2r->sensing_time[0] = '\0';
	s2r->l1proctime[0] = '\0';
	s2r->cs_name[0] = '\0';
	s2r->cs_code[0] = '\0';
	s2r->nr[0] = '\0'; /* saved as strings. "10980/5660/1830" */
	s2r->nc[0] = '\0'; /* saved as strings. "10980/5660/1830" */
	s2r->spatial_resolution[0] = '\0';  /* as strings */
	s2r->ululx = -1;	/* upper-left corner of the upper-left pixel. Same as ulx */
	s2r->ululy = -1;
	s2r->msz = -1;
	s2r->msa = -1;
	s2r->mvz = -1;
	s2r->mva = -1;
	s2r->spcover = -1;		/* Spatial coverage in percentage */
	s2r->clcover = -1; 		/* Cloud coverage in percentage, if present in ACmask or Fmask*/


	/* Allocate memory for READ, WRITE, or CREATE. */
	/* For DFACC_READ or DFACC_WRITE, find the image dimension from a 10m band, e.g. band 2.
	 */
	if (s2r->access_mode == DFACC_READ || s2r->access_mode == DFACC_WRITE) {
		int32 sd_id, sds_id;
		if ((sd_id = SDstart(s2r->fname, s2r->access_mode)) == FAIL) {
			sprintf(message, "Cannot open %s", s2r->fname);
			Error(message);
			return(ERR_READ);
		}

		strcpy(sds_name, S2_SDS_NAME[1]); /* a 10m SDS: B02 */
		if ((sds_index = SDnametoindex(sd_id, sds_name)) == FAIL) {
			sprintf(message, "Didn't find the SDS %s in %s", sds_name, s2r->fname);
			Error(message);
			return(ERR_READ);
		}
		sds_id = SDselect(sd_id, sds_index);
		if (SDgetinfo(sds_id, sds_name, &rank, dimsizes, &data_type, &nattr) == FAIL) {
			Error("Error in SDgetinfo");
			return(ERR_READ);
		} 
		SDendaccess(sds_id);
		SDend(sd_id);

		s2r->nrow[0] = dimsizes[0];
		s2r->ncol[0] = dimsizes[1];
	}

	/* for DFACC_CREATE, image dimension of 10m bands is directly given. */
	s2r->nrow[1] = s2r->nrow[0]/2;
	s2r->ncol[1] = s2r->ncol[0]/2;
	s2r->nrow[2] = s2r->nrow[0]/6;
	s2r->ncol[2] = s2r->ncol[0]/6;

	/* Now allocate memory for any access mode*/
	for (ib = 0; ib < S2NBAND; ib++) {
		psi = get_pixsz_index(ib);
		dimsizes[0] = s2r->nrow[psi];
		dimsizes[1] = s2r->ncol[psi];

		/* Allocate memory for read access */ 
		if ((s2r->ref[ib] = (int16*)calloc(dimsizes[0] * dimsizes[1], sizeof(int16))) == NULL) {
			sprintf(message, "Cannot allocate memory. nrow, ncol = %d, %d\n", s2r->nrow[psi], s2r->ncol[psi]);
			Error(message);
			return(1);
		}
	}


	/* Read CLOUD SDS generated by AC if desired */
	if (strcmp(s2r->ac_cloud_available, AC_CLOUD_AVAILABLE) == 0) {
		if ((s2r->accloud = (uint8*)calloc(s2r->nrow[0]*s2r->ncol[0], sizeof(uint8))) == NULL) {
			Error("Cannot allocate memory for s2r->accloud\n");
			return(1);
		}
	}

	/* The availability of the two masks (ACmask and Fmask) depends on the stages of processing. 
	 * The output from AC code does not have it, although it has CLOUD SDS which will be eventually
	 * renamed ACmask.
	 *
	 * The CLOUD SDS is at 10m and is renamed ACmask, and Fmask is originally at 20m and is to be
	 * over-sampled to 10m.
	 */
	if (strcmp(s2r->mask_unavailable, MASK_UNAVAILABLE) == 0) { 
		;
	}
	else {
		/* ACmask */
		if ((s2r->acmask = (uint8*)calloc(s2r->nrow[0]*s2r->ncol[0], sizeof(uint8))) == NULL) {
			Error("Cannot allocate memory for s2r->accloud\n");
			return(1);
		}
		/* Fmask */
		if ((s2r->fmask = (uint8*)calloc(s2r->nrow[0]*s2r->ncol[0], sizeof(uint8))) == NULL) {
			Error("Cannot allocate memory for s2r->fmask\n");
			return(1);
		}
	}


	/* Now read, write, or create*/
	if (s2r->access_mode == DFACC_READ || s2r->access_mode == DFACC_WRITE) {
		if ((s2r->sd_id = SDstart(s2r->fname, s2r->access_mode)) == FAIL) {
			sprintf(message, "Cannot open %s", s2r->fname);
			Error(message);
			return(ERR_READ);
		}

		/* Reflectance bands  */
		for (ib = 0; ib < S2NBAND; ib++) {
			strcpy(sds_name, S2_SDS_NAME[ib]);
			if ((sds_index = SDnametoindex(s2r->sd_id, sds_name)) == FAIL) {
				sprintf(message, "Didn't find the SDS %s in %s", sds_name, s2r->fname);
				Error(message);
				return(ERR_READ);
			}
			s2r->sds_id_ref[ib] = SDselect(s2r->sd_id, sds_index);

			if (SDgetinfo(s2r->sds_id_ref[ib], sds_name, &rank, dimsizes, &data_type, &nattr) == FAIL) {
				Error("Error in SDgetinfo");
				return(ERR_READ);
			} 

			psi = get_pixsz_index(ib);
			start[0] = 0; edge[0] = s2r->nrow[psi];
			start[1] = 0; edge[1] = s2r->ncol[psi];
			if (SDreaddata(s2r->sds_id_ref[ib], start, NULL, edge, s2r->ref[ib]) == FAIL) {
				sprintf(message, "Error reading sds %s in %s", sds_name, s2r->fname);
				Error(message);
				return(ERR_READ);
			}
		}

		/* AC CLOUD */
		if (strcmp(s2r->ac_cloud_available, AC_CLOUD_AVAILABLE) == 0) {
			strcpy(sds_name, AC_CLOUD_NAME);
			if ((sds_index = SDnametoindex(s2r->sd_id, sds_name)) == FAIL) {
				sprintf(message, "Didn't find the SDS %s in %s", sds_name, s2r->fname);
				Error(message);
				return(ERR_READ);
			}
			s2r->sds_id_accloud = SDselect(s2r->sd_id, sds_index);

			start[0] = 0; edge[0] = s2r->nrow[0];
			start[1] = 0; edge[1] = s2r->ncol[0];
			if (SDreaddata(s2r->sds_id_accloud, start, NULL, edge, s2r->accloud) == FAIL) {
				sprintf(message, "Error reading sds %s in %s", sds_name, s2r->fname);
				Error(message);
				return(ERR_READ);
			}
		}

		/* ACmask and Fmask */ 
		if (strcmp(s2r->mask_unavailable, MASK_UNAVAILABLE) == 0) { 
			; /* do nothing */
		}
		else {
			/* ACmask */
			strcpy(sds_name, ACMASK_NAME);
			if ((sds_index = SDnametoindex(s2r->sd_id, sds_name)) == FAIL) {
				sprintf(message, "Didn't find the SDS %s in %s", sds_name, s2r->fname);
				Error(message);
				return(ERR_READ);
			}
			s2r->sds_id_acmask = SDselect(s2r->sd_id, sds_index);

			start[0] = 0; edge[0] = s2r->nrow[0];
			start[1] = 0; edge[1] = s2r->ncol[0];
			if (SDreaddata(s2r->sds_id_acmask, start, NULL, edge, s2r->acmask) == FAIL) {
				sprintf(message, "Error reading sds %s in %s", sds_name, s2r->fname);
				Error(message);
				return(ERR_READ);
			}

			/* Fmask */
			strcpy(sds_name, FMASK_NAME);
			if ((sds_index = SDnametoindex(s2r->sd_id, sds_name)) == FAIL) {
				sprintf(message, "Didn't find the SDS %s in %s", sds_name, s2r->fname);
				Error(message);
				return(ERR_READ);
			}
			s2r->sds_id_fmask = SDselect(s2r->sd_id, sds_index);

			start[0] = 0; edge[0] = s2r->nrow[0];
			start[1] = 0; edge[1] = s2r->ncol[0];
			if (SDreaddata(s2r->sds_id_fmask, start, NULL, edge, s2r->fmask) == FAIL) {
				sprintf(message, "Error reading sds %s in %s", sds_name, s2r->fname);
				Error(message);
				return(ERR_READ);
			}
		}


		 /* Oct 18, 2016: Read a few map projection attributes, which are needed in processing
		  * and creating an ENVI header.
		 */
		/* ULX */
		strcpy(attr_name, ULX);
		if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
			sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
			Error(message);
			return (-1);
		}
		if (SDreadattr(s2r->sd_id, attr_index, &s2r->ulx) == FAIL) {
			sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
			Error(message);
			return(-1);
		}

		/* ULY */
		strcpy(attr_name, ULY);
		if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
			sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
			Error(message);
			return (-1);
		}
		if (SDreadattr(s2r->sd_id, attr_index, &s2r->uly) == FAIL) {
			sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
			Error(message);
			return(-1);
		}

		/* Read zonehem from HORIZONTAL_CS_NAME */
	 	/* from nchdfdump:   :HORIZONTAL_CS_NAME = "WGS84 / UTM zone 31N" ; */
		/* HORIZONTAL_CS_NAME*/
		char   tmpcsname[100], *tmppos;
		strcpy(attr_name, HORIZONTAL_CS_NAME);
		if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
			sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
			Error(message);
			return (-1);
		}
		if (SDattrinfo(s2r->sd_id, attr_index, attr_name, &data_type, &count) == FAIL) {
			Error("Error in SDattrinfo");
			return(-1);
		}
		if (count >= sizeof(tmpcsname)) {
			Error("tmpcsname is not big enough");
			return(-1);
		}
		if (SDreadattr(s2r->sd_id, attr_index, tmpcsname) == FAIL) {
			sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
			Error(message);
			return(-1);
		}
		tmpcsname[count] = '\0';
		tmppos = strrchr(tmpcsname, ' ');
		strcpy(s2r->zonehem, tmppos+1);
	}
	else if (s2r->access_mode == DFACC_CREATE) {
		char *dimnames[][2] =  {{"YDim_Grid_10m", "XDim_Grid_10m"},
					{"YDim_Grid_20m", "XDim_Grid_20m"},
					{"YDim_Grid_60m", "XDim_Grid_60m"}};
		int32 comp_type;   /*Compression flag*/
		comp_info c_info;  /*Compression structure*/
		comp_type = COMP_CODE_DEFLATE;
		c_info.deflate.level = 2;     /*Level 9 would be too slow */
		rank = 2;

		int irow, icol;

		if (s2r->nrow[0] == 0) {
			sprintf(message, "Image dimension not set correctly: nrow = %d, %s\n", s2r->nrow[0], s2r->fname);	
			Error(message);
			exit(1);
		}
		else if (s2r->nrow[0]/3 != HLS_TILEDIM_30M) { 
			sprintf(message, "Image dimension not set correctly: nrow = %d, %s\n", s2r->nrow[0], s2r->fname);	
			Error(message);
			exit(1);
		}
		/* Memory has been allocated earlier */

		if ((s2r->sd_id = SDstart(s2r->fname, s2r->access_mode)) == FAIL) {
			sprintf(message, "Cannot create %s", s2r->fname);
			Error(message);
			return(ERR_CREATE);
		}

		for (ib = 0; ib < S2NBAND; ib++) {
			strcpy(sds_name, S2_SDS_NAME[ib]);
			psi = get_pixsz_index(ib);
			dimsizes[0] = s2r->nrow[psi];
			dimsizes[1] = s2r->ncol[psi];

			if ((s2r->sds_id_ref[ib] = SDcreate(s2r->sd_id, sds_name, DFNT_INT16, rank, dimsizes)) == FAIL) {
				sprintf(message, "Cannot create SDS %s", sds_name);
				Error(message);
				return(ERR_CREATE);
			}    
			PutSDSDimInfo(s2r->sds_id_ref[ib], dimnames[psi][0], 0);
			PutSDSDimInfo(s2r->sds_id_ref[ib], dimnames[psi][1], 1);
			SDsetcompress(s2r->sds_id_ref[ib], comp_type, &c_info);	
			SDsetattr(s2r->sds_id_ref[ib], "long_name",  
					DFNT_CHAR8, strlen(S2_SDS_LONG_NAME[ib]), (VOIDP)S2_SDS_LONG_NAME[ib]);
			SDsetattr(s2r->sds_id_ref[ib], "_FillValue", DFNT_CHAR8, strlen(S2_ref_fillval), (VOIDP)S2_ref_fillval);
			SDsetattr(s2r->sds_id_ref[ib], "scale_factor", DFNT_CHAR8, 
							strlen(S2_ref_scale_factor), (VOIDP)S2_ref_scale_factor);
			SDsetattr(s2r->sds_id_ref[ib], "add_offset", DFNT_CHAR8, 
							strlen(S2_ref_add_offset), (VOIDP)S2_ref_add_offset);

			for (irow = 0; irow < dimsizes[0]; irow++) {
				for (icol = 0; icol < dimsizes[1]; icol++) 
					s2r->ref[ib][irow*dimsizes[1]+icol] = ref_fillval;
			}
		}

		/* CLOUD SDS from AC code */
		if (strcmp(s2r->ac_cloud_available, AC_CLOUD_AVAILABLE) == 0) {
			strcpy(sds_name, AC_CLOUD_NAME);
			dimsizes[0] = s2r->nrow[0];
			dimsizes[1] = s2r->ncol[0];
			if ((s2r->sds_id_accloud = SDcreate(s2r->sd_id, sds_name, DFNT_UINT8, rank, dimsizes)) == FAIL) {
				sprintf(message, "Cannot create SDS %s", sds_name);
				Error(message);
				return(ERR_CREATE);
			}    
			PutSDSDimInfo(s2r->sds_id_accloud, dimnames[0][0], 0);
			PutSDSDimInfo(s2r->sds_id_accloud, dimnames[0][1], 1);
			SDsetcompress(s2r->sds_id_accloud, comp_type, &c_info);	
			SDsetattr(s2r->sds_id_accloud, "_FillValue", DFNT_UINT8, 1, (VOIDP)&S2_mask_fillval);

			for (irow = 0; irow < dimsizes[0]; irow++) {
				for (icol = 0; icol < dimsizes[1]; icol++) 
					s2r->accloud[irow*dimsizes[1]+icol] = S2_mask_fillval; 
			}
		}

		/* Two masks */
		if (strcmp(s2r->mask_unavailable, MASK_UNAVAILABLE) == 0) { 
			; /* do nothing */
		}
		else {
			char attr[3000];

			/* AC mask */
			strcpy(sds_name, ACMASK_NAME);
			dimsizes[0] = s2r->nrow[0];
			dimsizes[1] = s2r->ncol[0];
			if ((s2r->sds_id_acmask = SDcreate(s2r->sd_id, sds_name, DFNT_UINT8, rank, dimsizes)) == FAIL) {
				sprintf(message, "Cannot create SDS %s", sds_name);
				Error(message);
				return(ERR_CREATE);
			}    
			PutSDSDimInfo(s2r->sds_id_acmask, dimnames[0][0], 0);
			PutSDSDimInfo(s2r->sds_id_acmask, dimnames[0][1], 1);
			SDsetcompress(s2r->sds_id_acmask, comp_type, &c_info);	
			SDsetattr(s2r->sds_id_acmask, "_FillValue", DFNT_UINT8, 1, (VOIDP)&S2_mask_fillval);

			/* Note: For better view, the blanks within the string is blank space characters, not tab */
			sprintf(attr, 	"Bits are listed from the MSB (bit 7) to the LSB (bit 0): \n"
					"7-6    aerosol:\n"
					"       00 - climatology\n"
					"       01 - low\n"
					"       10 - average\n"
					"       11 - high\n"
					"5      water\n"
					"4      snow/ice\n"
					"3      cloud shadow\n"
					"2      adjacent to cloud\n"
					"1      cloud\n"
					"0      cirrus cloud\n");
			SDsetattr(s2r->sds_id_acmask, "ACmask bit description", DFNT_CHAR8, strlen(attr), (VOIDP)attr);

			for (irow = 0; irow < dimsizes[0]; irow++) {
				for (icol = 0; icol < dimsizes[1]; icol++) 
					s2r->acmask[irow*dimsizes[1]+icol] = S2_mask_fillval; 
			}

			
			/* Fmask */
			strcpy(sds_name, FMASK_NAME);
			dimsizes[0] = s2r->nrow[0];
			dimsizes[1] = s2r->ncol[0];
			if ((s2r->sds_id_fmask = SDcreate(s2r->sd_id, sds_name, DFNT_UINT8, rank, dimsizes)) == FAIL) {
				sprintf(message, "Cannot create SDS %s", sds_name);
				Error(message);
				return(ERR_CREATE);
			}    
			PutSDSDimInfo(s2r->sds_id_fmask, dimnames[0][0], 0);
			PutSDSDimInfo(s2r->sds_id_fmask, dimnames[0][1], 1);
			SDsetcompress(s2r->sds_id_fmask, comp_type, &c_info);	
			SDsetattr(s2r->sds_id_fmask, "_FillValue", DFNT_UINT8, 1, (VOIDP)&S2_mask_fillval);

			/* Note: For better view, the blanks within the string is blank space characters, not tab */
			sprintf(attr, 	"Bits are listed from the MSB (bit 7) to the LSB (bit 0): \n"
					"7-6    aerosol:\n"
					"       00 - climatology\n"
					"       01 - low\n"
					"       10 - average\n"
					"       11 - high\n"
					"5      water\n"
					"4      snow/ice\n"
					"3      cloud shadow\n"
					"1      cloud\n"
					"0      cirrus cloud\n");
			SDsetattr(s2r->sds_id_fmask, "Fmask bit description", DFNT_CHAR8, strlen(attr), (VOIDP)attr);

			for (irow = 0; irow < dimsizes[0]; irow++) {
				for (icol = 0; icol < dimsizes[1]; icol++) 
					s2r->fmask[irow*dimsizes[1]+icol] = S2_mask_fillval; 
			}

		}
	}

	return 0;
} 



/* S2 data are at three different pixel sizes, 10m, 20m, and 60m.
   For a given band index, the index of its pixel size class in various arrays 
   need to be found: 10m at location 0, 20m at 1, and 60m at 2. 
   The input band index ranges from 0 to 12, corresponding to almost the 
   band numbers in the wavelength order; in particular, band 8a is given an index 8. 
*/
int get_pixsz_index(int bandidx)
{
	int psi;

	switch (bandidx) {
		case 0:  psi = 2; break;	/* 60m, coastal/aerosl */
		case 1:  psi = 0; break;	/* 10m, blue */	
		case 2:  psi = 0; break;	/* 10m, green */
		case 3:  psi = 0; break;	/* 10m, red */
		case 4:  psi = 1; break;	/* 20m, red edge 1 */
		case 5:  psi = 1; break;	/* 20m, red edge 2 */
		case 6:  psi = 1; break;	/* 20m, red edge 3 */
		case 7:  psi = 0; break;	/* 10m, nir */
		case 8:  psi = 1; break;	/* 20m, nir 8a */
		case 9:  psi = 2; break;	/* 60m, water vapor*/
		case 10: psi = 2; break;	/* 60m, cirrus*/
		case 11: psi = 1; break;	/* 20m, SWIR1*/
		case 12: psi = 1; break;	/* 20m, SWIR2*/
		default: fprintf(stderr, "Band index out of range: bandidx = %d\n", bandidx); exit(1);
	}

	return psi;
}

/* Where is it used now?   Jul 9, 2019: in ppS10/resamp_s2.c. When AROP fitting is invalid,
 * duplicate input to output. */
void dup_s2(s2r_t *in, s2r_t *out)
{
	int ib;
	int psi;
	int k, npix;

	/* Signal to set spatial and cloud coverage for output file*/

	/* Needed for map projection */
	strcpy(out->zonehem, in->zonehem);
	out->ulx = in->ulx;
	out->uly = in->uly;

	for (ib = 0; ib < S2NBAND; ib++) {
		psi = get_pixsz_index(ib);
		npix = in->nrow[psi] * in->ncol[psi];
		for (k = 0; k < npix; k++)
			out->ref[ib][k] = in->ref[ib][k];
	}

	/* ACmask and Fmask */
	npix = in->nrow[0] * in->ncol[0];
	for (k = 0; k < npix; k++) {
		out->acmask[k] = in->acmask[k];
		out->fmask[k] = in->fmask[k];
	}
}


/* close */
int close_s2r(s2r_t *s2r)
{
	int ib;
	int psi;
	int ret;
	char message[MSGLEN];
	int32 start[2], edge[2];
	
	if ((s2r->access_mode == DFACC_WRITE || s2r->access_mode == DFACC_CREATE) && s2r->sd_id != FAIL) {
		for (ib = 0; ib < S2NBAND; ib++) {
			psi = get_pixsz_index(ib);
			start[0] = 0; edge[0] = s2r->nrow[psi];
			start[1] = 0; edge[1] = s2r->ncol[psi];
			if (SDwritedata(s2r->sds_id_ref[ib], start, NULL, edge, s2r->ref[ib]) == FAIL) {
				sprintf(message, "Error in SDwritedata, ib = %d", ib);
				Error(message);
				//return(ERR_CREATE);
			}
			SDendaccess(s2r->sds_id_ref[ib]);
		}

		/* AC CLOUD */
		/* Jun 26, 2019: This is used only when the two hdf from AC are to be combined */
		if (strcmp(s2r->ac_cloud_available, AC_CLOUD_AVAILABLE) == 0) {
			start[0] = 0; edge[0] = s2r->nrow[0];
			start[1] = 0; edge[1] = s2r->ncol[0];
			if (SDwritedata(s2r->sds_id_accloud, start, NULL, edge, s2r->accloud) == FAIL) {
				Error("Error in SDwritedata");
				return(ERR_CREATE);
			}
			SDendaccess(s2r->sds_id_accloud);
		}

		/* ACmask */	
		if (s2r->acmask != NULL) { 
			start[0] = 0; edge[0] = s2r->nrow[0];    /*  10m */
			start[1] = 0; edge[1] = s2r->ncol[0];
			if (SDwritedata(s2r->sds_id_acmask, start, NULL, edge, s2r->acmask) == FAIL) {
				Error("Error in SDwritedata");
				return(ERR_CREATE);
			}
			SDendaccess(s2r->sds_id_acmask);
		}

		/* Fmask */	
		if (s2r->fmask != NULL) { 
			start[0] = 0; edge[0] = s2r->nrow[0];    /*  10m */
			start[1] = 0; edge[1] = s2r->ncol[0];
			if (SDwritedata(s2r->sds_id_fmask, start, NULL, edge, s2r->fmask) == FAIL) {
				Error("Error in SDwritedata");
				return(ERR_CREATE);
			}
			SDendaccess(s2r->sds_id_fmask);
		}

		SDend(s2r->sd_id);
		s2r->sd_id = FAIL;

		/* Add an ENVI header */  
		char header[500];
		double pixsz = 10;
		sprintf(header, "%s.hdr", s2r->fname);
		ret = add_envi_utm_header(s2r->zonehem, s2r->ulx, s2r->uly, s2r->nrow[0], s2r->ncol[0],  pixsz, header);
		if (ret != 0) {
			sprintf(message, "Error in add_envi_utm_header for %s ", s2r->fname);
			Error(message);
			exit(1);
		}
	}
	else if (s2r->access_mode == DFACC_READ && s2r->sd_id != FAIL) {
		for (ib = 0; ib < S2NBAND; ib++) 
			SDendaccess(s2r->sds_id_ref[ib]);

		SDendaccess(s2r->sds_id_acmask);
		SDendaccess(s2r->sds_id_fmask);

		SDend(s2r->sd_id);
		s2r->sd_id = FAIL;
	}

	/* free up memory */
	for (ib = 0; ib < S2NBAND; ib++) {
		if (s2r->ref[ib] != NULL) {
			free(s2r->ref[ib]);
			s2r->ref[ib] = NULL;
		}
	}
	if (s2r->accloud != NULL) {
		free(s2r->accloud );
		s2r->accloud = NULL;
	}
	if (s2r->acmask != NULL) {
		free(s2r->acmask);
		s2r->acmask = NULL;
	}
	if (s2r->fmask != NULL) {
		free(s2r->fmask);
		s2r->fmask = NULL;
	}

	return 0;
}


/* Spaital and cloud coverage in a tile in percentage */
void setcoverage(s2r_t *s2r)
{
	int irow, icol;
	int npix, ncloud, k; 

	/* Coverage is based on broad NIR band. For S10 output, cloud cover SDS was
	 * available at 10m. So chose a 10m NIR*/
	
	npix = 0;
	ncloud = 0;
	for (irow = 0; irow < s2r->nrow[0]; irow++) {		/* 0, 1, 2 for 10m, 20m, 60m respectively */
		for (icol = 0; icol < s2r->ncol[0]; icol++) {
			k = irow*s2r->ncol[0]+icol;
			if (s2r->ref[7][k] != HLS_S2_FILLVAL) {	/* 7 is for 10m NIR */
				npix++;
				/* cirrus, cloud, and cloud shadow, aggressively based on ACmask and Fmask. */
				
				/* Ignore acmask because it is only a dummy SDS. 9/22/2020. 
				if ( ((s2r->acmask[k] & 1) == 1 || ((s2r->acmask[k] >> 1) & 1) == 1 || ((s2r->acmask[k] >> 3) & 1) == 1) ||
				     ((s2r->fmask[k] & 1) == 1  || ((s2r->fmask[k] >> 1) & 1) == 1  || ((s2r->fmask[k] >> 3) & 1) == 1))
					ncloud++;
				*/
				if ( (s2r->fmask[k] & 1) == 1  || ((s2r->fmask[k] >> 1) & 1) == 1  || ((s2r->fmask[k] >> 3) & 1) == 1)
					ncloud++;
			}
		}
	}

	s2r->spcover = (int) (npix * 100.0 / (s2r->nrow[0] * s2r->ncol[0]));
	s2r->clcover = (int) (ncloud * 100.0 / npix + 0.5);

	SDsetattr(s2r->sd_id, SPCOVER, DFNT_INT16, 1, (VOIDP)&(s2r->spcover));
	SDsetattr(s2r->sd_id, CLCOVER, DFNT_INT16, 1, (VOIDP)&(s2r->clcover));
}

/* Parse a line of XML for the metadata value (enclosed in <>) and return the beginning character 
 * location and the number of characters in the value for copying.
 * 
 * If the calling function assumes the XML is always right, then no need to check the
 * validity of the return.  Check if n is 0.
 *
 * Used by setinputmeta() 
 * 
 * Jan 07, 2017.
 */
char * xmlval(char *line, int *n)
{
	char *cb, *ce; 	/* begin char and end char */
	cb = ce = NULL;

	*n = 0;
	cb = strchr(line, '>');
	if (cb != NULL) {
		cb++;
		ce = strchr(cb, '<');
		if (ce != NULL && cb < ce )
			*n = ce - cb;
		else
			cb = NULL;
	}
	return (cb);
}

int setinputmeta(s2r_t *s2r, char *safexml, char *granulexml, char *accode)
{
	FILE *fsxml;	/* SAFE xml */
	FILE *fgxml;	/* granule xml */
	char line[500], prevline[500];
	char *cb; /* beginning char of a pattern */
	char attr[200];
	int nc; 	/* n char */ 
	char message[MSGLEN];
	int ret, n, before_sun, before_view;

	/********** First level metadata from the SAFE xml */
	if ((fsxml = fopen(safexml, "r")) == NULL) {
		sprintf(message, "Cannot open %s", safexml);
		Error(message);
		return(1);
	}
	while (fgets(line, sizeof(line), fsxml)) {
		if (strstr(line, "PRODUCT_URI")) {
			cb = xmlval(line, &nc);	
			strncpy(s2r->uri, cb, nc);
			s2r->uri[nc] = '\0';
		}
		/* PROCESSING_BASELINE is in the SAFE xml, not the granule xml; wasted a few hours.
		 * (Earlier it was read from the datastrip xml.  It seems the attribute value must 
		 *  have non-zero length -- baseline has been initialized to zero-length string, 
		 *  but its emptiness  had corrupted the whole file.)
		 */
		else if (strstr(line, PROCESSING_BASELINE)) {	
			cb = xmlval(line, &nc);	
			strncpy(s2r->baseline, cb, nc);
			s2r->baseline[nc] = '\0';
		}
		else if (strstr(line, SPACECRAFT)) {	
			cb = xmlval(line, &nc);	
			strncpy(s2r->spacecraft, cb, nc);
			s2r->spacecraft[nc] = '\0';
		}
		else if (strstr(line, "SENSOR_QUALITY_FLAG")) {
			/* concatenate the quality flags as it is read. If any flag is missing,
			 * it won't appear in s2r->quality, and does not cause crash.
			 * (Some product only has 4 flags. That is why these metadata are
			 *  not written as separate items. 2/2/17)
			 */
			cb = xmlval(line, &nc);	
			strncpy(attr, cb, nc);
			attr[nc] = '\0';
			sprintf(s2r->quality, "%sSENSOR:%s ", s2r->quality, attr);
		} 
		else if (strstr(line, "GEOMETRIC_QUALITY_FLAG")) {
			cb = xmlval(line, &nc);	
			strncpy(attr, cb, nc);
			attr[nc] = '\0';
			sprintf(s2r->quality, "%sGEOMETRIC:%s ", s2r->quality, attr);
		}
		else if (strstr(line, "GENERAL_QUALITY_FLAG")) {
			cb = xmlval(line, &nc);	
			strncpy(attr, cb, nc);
			attr[nc] = '\0';
			sprintf(s2r->quality, "%sGENERAL:%s ", s2r->quality, attr);
		}
		else if (strstr(line, "FORMAT_CORRECTNESS_FLAG")) {
			cb = xmlval(line, &nc);	
			strncpy(attr, cb, nc);
			attr[nc] = '\0';
			sprintf(s2r->quality, "%sFORMAT:%s ", s2r->quality, attr);
		}
		else if (strstr(line, "RADIOMETRIC_QUALITY_FLAG")) {
			cb = xmlval(line, &nc);	
			strncpy(attr, cb, nc);
			attr[nc] = '\0';
			sprintf(s2r->quality, "%sRADIOMETRIC:%s ", s2r->quality, attr);
		}
	}
	fclose(fsxml);
	

	/********** Other metadata */
	if ((fgxml = fopen(granulexml, "r")) == NULL) {
		sprintf(message, "Cannot open %s", granulexml);
		Error(message);
		return(1);
	}

	n = before_sun = before_view = 0;
	while (fgets(line, sizeof(line), fgxml)) {
		n++;
		if (strstr(line, TILE_ID)) {
			cb = xmlval(line, &nc);	
			strncpy(s2r->tile_id, cb, nc);
			s2r->tile_id[nc] = '\0';
		}
		else if (strstr(line, DATASTRIP_ID)) {
			cb = xmlval(line, &nc);	
			strncpy(s2r->datastrip_id, cb, nc);
			s2r->datastrip_id[nc] = '\0';
		}
		else if (strstr(line, SENSING_TIME)) {
			cb = xmlval(line, &nc);	
			strncpy(s2r->sensing_time, cb, nc);
			s2r->sensing_time[nc] = '\0';
		}
		else if (strstr(line, ARCHIVING_TIME)) {
			cb = xmlval(line, &nc);	
			strncpy(s2r->l1proctime, cb, nc);
			s2r->l1proctime[nc] = '\0';
		}
		else if (strstr(line, HORIZONTAL_CS_NAME)) {
			/* Jun 9, 2016: This items contains 20 char exactly. With '\0'
			 * the C char array should have minimum length 21, but I initially 
			 * declared 20 mistakenly. A bug took a few hours to find. 
			 */
			cb = xmlval(line, &nc);	
			strncpy(s2r->cs_name, cb, nc);
			s2r->cs_name[nc] = '\0';
		} 
		else if (strstr(line, HORIZONTAL_CS_CODE)) {
			cb = xmlval(line, &nc);	
			strncpy(s2r->cs_code, cb, nc);
			s2r->cs_code[nc] = '\0';
		} 
		else if (strstr(line, ULX)) {	/* Appears three times for 3 resolution, but same value */
			cb = xmlval(line, &nc);	
			s2r->ululx = atof(cb);
		}
		else if (strstr(line, ULY)) {	/* Appears three times for 3 resolution, but same value */
			cb = xmlval(line, &nc);	
			s2r->ululy = atof(cb);
		}
		else if (strstr(line, "<Mean_Sun_Angle>")) {
			before_sun = n;
		}
		else if (n == before_sun + 1 && strstr(line, "ZENITH_ANGLE")) {
			cb = xmlval(line, &nc);	
			s2r->msz = atof(cb);
		}
		else if (n == before_sun + 2 && strstr(line, "AZIMUTH_ANGLE")) {
			cb = xmlval(line, &nc);	
			s2r->msa = atof(cb);
		}
		else if (strstr(line, "<Mean_Viewing_Incidence_Angle bandId=\"0\"")) {
			before_view = n;
		}
		else if (n == before_view + 1 && strstr(line, "ZENITH_ANGLE")) {
			cb = xmlval(line, &nc);	
			s2r->mvz = atof(cb);
		}
		else if (n == before_view + 2 && strstr(line, "AZIMUTH_ANGLE")) {
			cb = xmlval(line, &nc);	
			s2r->mva = atof(cb);
			
			break;
		}
	}
	fclose(fgxml);

	/* For S10 only. Will change to 3660 and 30 for S30 */
	strcpy(s2r->nr, "10980/5490/1830"); 
	strcpy(s2r->nc, "10980/5490/1830"); 
	strcpy(s2r->spatial_resolution, "10/20/60");

	/* Jun 8, 2016: By mistake cs_code was not set and whole set of attributes are ruined */
	/* Nov 15, 2016: No longer add SAFE name as attributes,
	 * Jan 20, 2017: but product URI is added 
   	 */

	/* Be more defensive?  Jan 20, 2017.
	 * Eventually should check if all attributes have been set.
	 */
	if (strlen(s2r->uri) == 0)
		strcpy(s2r->uri, "NONE");
	if (strlen(s2r->quality) == 0)
		strcpy(s2r->quality, "NONE");
	if (strlen(s2r->spacecraft) == 0)
		strcpy(s2r->spacecraft, "NONE");
	if (strlen(s2r->tile_id) == 0)
		strcpy(s2r->tile_id, "NONE");
	if (strlen(s2r->datastrip_id) == 0)
		strcpy(s2r->datastrip_id, "NONE");
	if (strlen(s2r->baseline) == 0)
		strcpy(s2r->baseline, "NONE");

	
	SDsetattr(s2r->sd_id, PRODUCT_URI, DFNT_CHAR8, strlen(s2r->uri), (VOIDP)s2r->uri);
	SDsetattr(s2r->sd_id, L1C_QUALITY, DFNT_CHAR8, strlen(s2r->quality), (VOIDP)s2r->quality);
	SDsetattr(s2r->sd_id, SPACECRAFT, DFNT_CHAR8, strlen(s2r->spacecraft), (VOIDP)s2r->spacecraft);
	SDsetattr(s2r->sd_id, TILE_ID, DFNT_CHAR8, strlen(s2r->tile_id), (VOIDP)s2r->tile_id);
	SDsetattr(s2r->sd_id, DATASTRIP_ID, DFNT_CHAR8, strlen(s2r->datastrip_id), (VOIDP)s2r->datastrip_id);
	SDsetattr(s2r->sd_id, PROCESSING_BASELINE, DFNT_CHAR8, strlen(s2r->baseline), (VOIDP)s2r->baseline);
	SDsetattr(s2r->sd_id, SENSING_TIME, DFNT_CHAR8, strlen(s2r->sensing_time), (VOIDP)s2r->sensing_time);
	SDsetattr(s2r->sd_id, L1PROCTIME, DFNT_CHAR8, strlen(s2r->l1proctime), (VOIDP)s2r->l1proctime);
	SDsetattr(s2r->sd_id, HORIZONTAL_CS_NAME, DFNT_CHAR8, strlen(s2r->cs_name), (VOIDP)s2r->cs_name);
	SDsetattr(s2r->sd_id, HORIZONTAL_CS_CODE, DFNT_CHAR8, strlen(s2r->cs_code), (VOIDP)s2r->cs_code);
	SDsetattr(s2r->sd_id, NROWS, DFNT_CHAR8, strlen(s2r->nr), (VOIDP)s2r->nr);
	SDsetattr(s2r->sd_id, NCOLS, DFNT_CHAR8, strlen(s2r->nc), (VOIDP)s2r->nc);
	SDsetattr(s2r->sd_id, SPATIAL_RESOLUTION, DFNT_CHAR8, strlen(s2r->spatial_resolution), (VOIDP)s2r->spatial_resolution);
	SDsetattr(s2r->sd_id, ULX, DFNT_FLOAT64, 1, (VOIDP)&(s2r->ululx));
	SDsetattr(s2r->sd_id, ULY, DFNT_FLOAT64, 1, (VOIDP)&(s2r->ululy));
	SDsetattr(s2r->sd_id, MSZ, DFNT_FLOAT64, 1, (VOIDP)&(s2r->msz));
	SDsetattr(s2r->sd_id, MSA, DFNT_FLOAT64, 1, (VOIDP)&(s2r->msa));
	SDsetattr(s2r->sd_id, MVZ, DFNT_FLOAT64, 1, (VOIDP)&(s2r->mvz));
	SDsetattr(s2r->sd_id, MVA, DFNT_FLOAT64, 1, (VOIDP)&(s2r->mva));

	/* Additional. 11/21/17 */
	SDsetattr(s2r->sd_id, ACCODE, DFNT_CHAR8, strlen(accode), (VOIDP)accode);

	return(0);
}


/* Read all the metadata: the input metadata set in the above function, plus spatial and cloud coverage. 
 * Dec 28, 2016: Additional metadata includes AROP-related metadata.
 */ 
int get_all_metadata(s2r_t *s2r)
{
	int32 nattr, attr_index;
	int count;
	char attr_name[200];
	int32 data_type;
	char message[MSGLEN];

	/* PRODUCT URI */
	strcpy(attr_name, PRODUCT_URI);
	if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
		/* Jan 29, 2017: Temporary solution. If attribute not found, should bail out */
		sprintf(message, "Attribute \"%s\" not found in %s. Set to NONE", attr_name, s2r->fname);
		Error(message);
		strcpy(s2r->uri, "NONE");
	}
	else {
		if (SDattrinfo(s2r->sd_id, attr_index, attr_name, &data_type, &count) == FAIL) {
			Error("Error in SDattrinfo");
			return(-1);
		}
		if (SDreadattr(s2r->sd_id, attr_index, s2r->uri) == FAIL) {
			sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
			Error(message);
			return(-1);
		}
		s2r->uri[count] = '\0';
	}

	/* QUALITY */
	strcpy(attr_name, L1C_QUALITY);
	if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
		sprintf(message, "Attribute \"%s\" not found in %s. Set to NONE", attr_name, s2r->fname);
		Error(message);
		strcpy(s2r->quality, "NONE");
	}
	else {
		if (SDattrinfo(s2r->sd_id, attr_index, attr_name, &data_type, &count) == FAIL) {
			Error("Error in SDattrinfo");
			return(-1);
		}
		if (SDreadattr(s2r->sd_id, attr_index, s2r->quality) == FAIL) {
			sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
			Error(message);
			return(-1);
		}
		s2r->quality[count] = '\0';
	}
	
	/* SPACECRAFT */
	strcpy(attr_name, SPACECRAFT);
	if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
		sprintf(message, "Attribute \"%s\" not found in %s. Set to NONE", attr_name, s2r->fname);
		Error(message);
		strcpy(s2r->spacecraft, "NONE");
	}
	else {
		if (SDattrinfo(s2r->sd_id, attr_index, attr_name, &data_type, &count) == FAIL) {
			Error("Error in SDattrinfo");
			return(-1);
		}
		if (SDreadattr(s2r->sd_id, attr_index, s2r->spacecraft) == FAIL) {
			sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
			Error(message);
			return(-1);
		}
		s2r->spacecraft[count] = '\0';
	}
	
	/* TILE_ID */
	strcpy(attr_name, TILE_ID);
	if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
		sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
		Error(message);
		return (-1);
	}
	if (SDattrinfo(s2r->sd_id, attr_index, attr_name, &data_type, &count) == FAIL) {
		Error("Error in SDattrinfo");
		return(-1);
	}
	if (SDreadattr(s2r->sd_id, attr_index, s2r->tile_id) == FAIL) {
		sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
		Error(message);
		return(-1);
	}
	s2r->tile_id[count] = '\0';

	/* DATASTRIP_ID */
	strcpy(attr_name, DATASTRIP_ID);
	if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
		sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
		Error(message);
		return (-1);
	}
	if (SDattrinfo(s2r->sd_id, attr_index, attr_name, &data_type, &count) == FAIL) {
		Error("Error in SDattrinfo");
		return(-1);
	}
	if (SDreadattr(s2r->sd_id, attr_index, s2r->datastrip_id) == FAIL) {
		sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
		Error(message);
		return(-1);
	}
	s2r->datastrip_id[count] = '\0';

	/* PROCESSING_BASELINE */
	strcpy(attr_name, PROCESSING_BASELINE);
	if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
		sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
		Error(message);
		return (-1);
	}
	if (SDattrinfo(s2r->sd_id, attr_index, attr_name, &data_type, &count) == FAIL) {
		Error("Error in SDattrinfo");
		return(-1);
	}
	if (SDreadattr(s2r->sd_id, attr_index, s2r->baseline) == FAIL) {
		sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
		Error(message);
		return(-1);
	}
	s2r->baseline[count] = '\0';

	/* SENSING_TIME*/
	strcpy(attr_name, SENSING_TIME);
	if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
		sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
		Error(message);
		return (-1);
	}
	if (SDattrinfo(s2r->sd_id, attr_index, attr_name, &data_type, &count) == FAIL) {
		Error("Error in SDattrinfo");
		return(-1);
	}
	if (SDreadattr(s2r->sd_id, attr_index, s2r->sensing_time) == FAIL) {
		sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
		Error(message);
		return(-1);
	}
	s2r->sensing_time[count] = '\0';

	/* L1PROCTIME */
	strcpy(attr_name, L1PROCTIME);
	if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
		sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
		Error(message);
		return (-1);
	}
	if (SDattrinfo(s2r->sd_id, attr_index, attr_name, &data_type, &count) == FAIL) {
		Error("Error in SDattrinfo");
		return(-1);
	}
	if (SDreadattr(s2r->sd_id, attr_index, s2r->l1proctime) == FAIL) {
		sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
		Error(message);
		return(-1);
	}
	s2r->l1proctime[count] = '\0';

	/* HORIZONTAL_CS_NAME*/
	strcpy(attr_name, HORIZONTAL_CS_NAME);
	if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
		sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
		Error(message);
		return (-1);
	}
	if (SDattrinfo(s2r->sd_id, attr_index, attr_name, &data_type, &count) == FAIL) {
		Error("Error in SDattrinfo");
		return(-1);
	}
	if (SDreadattr(s2r->sd_id, attr_index, s2r->cs_name) == FAIL) {
		sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
		Error(message);
		return(-1);
	}
	s2r->cs_name[count] = '\0';

	/* HORIZONTAL_CS_CODE */
	strcpy(attr_name, HORIZONTAL_CS_CODE);
	if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
		sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
		Error(message);
		return (-1);
	}
	if (SDattrinfo(s2r->sd_id, attr_index, attr_name, &data_type, &count) == FAIL) {
		Error("Error in SDattrinfo");
		return(-1);
	}
	if (SDreadattr(s2r->sd_id, attr_index, s2r->cs_code) == FAIL) {
		sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
		Error(message);
		return(-1);
	}
	s2r->cs_code[count] = '\0';

	/* NROWS */   /* It is a string. because nrows as integers have been used */
	strcpy(attr_name, NROWS);
	if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
		sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
		Error(message);
		return (-1);
	}
	if (SDattrinfo(s2r->sd_id, attr_index, attr_name, &data_type, &count) == FAIL) {
		Error("Error in SDattrinfo");
		return(-1);
	}
	if (SDreadattr(s2r->sd_id, attr_index, s2r->nr) == FAIL) {
		sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
		Error(message);
		return(-1);
	}
	s2r->nr[count] = '\0';

	/* NCOLS*/   
	strcpy(attr_name, NCOLS);
	if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
		sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
		Error(message);
		return (-1);
	}
	if (SDattrinfo(s2r->sd_id, attr_index, attr_name, &data_type, &count) == FAIL) {
		Error("Error in SDattrinfo");
		return(-1);
	}
	if (SDreadattr(s2r->sd_id, attr_index, s2r->nc) == FAIL) {
		sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
		Error(message);
		return(-1);
	}
	s2r->nc[count] = '\0';

	/* SPATIAL_RESOLUTION*/   
	strcpy(attr_name, SPATIAL_RESOLUTION);
	if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
		sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
		Error(message);
		return (-1);
	}
	if (SDattrinfo(s2r->sd_id, attr_index, attr_name, &data_type, &count) == FAIL) {
		Error("Error in SDattrinfo");
		return(-1);
	}
	if (SDreadattr(s2r->sd_id, attr_index, s2r->spatial_resolution) == FAIL) {
		sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
		Error(message);
		return(-1);
	}
	s2r->spatial_resolution[count] = '\0';

	/* ULX */
	strcpy(attr_name, ULX);
	if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
		sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
		Error(message);
		return (-1);
	}
	if (SDreadattr(s2r->sd_id, attr_index, &s2r->ululx) == FAIL) {
		sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
		Error(message);
		return(-1);
	}

	/* ULY */
	strcpy(attr_name, ULY);
	if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
		sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
		Error(message);
		return (-1);
	}
	if (SDreadattr(s2r->sd_id, attr_index, &s2r->ululy) == FAIL) {
		sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
		Error(message);
		return(-1);
	}

	/* MSZ*/   
	strcpy(attr_name, MSZ);
	if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
		sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
		Error(message);
		return (-1);
	}
	if (SDreadattr(s2r->sd_id, attr_index, &s2r->msz) == FAIL) {
		sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
		Error(message);
		return(-1);
	}

	/* MSA*/   
	strcpy(attr_name, MSA);
	if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
		sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
		Error(message);
		return (-1);
	}
	if (SDreadattr(s2r->sd_id, attr_index, &s2r->msa) == FAIL) {
		sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
		Error(message);
		return(-1);
	}

	/* MVZ*/   
	strcpy(attr_name, MVZ);
	if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
		sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
		Error(message);
		return (-1);
	}
	if (SDreadattr(s2r->sd_id, attr_index, &s2r->mvz) == FAIL) {
		sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
		Error(message);
		return(-1);
	}

	/* MVA*/   
	strcpy(attr_name, MVA);
	if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
		sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
		Error(message);
		return (-1);
	}
	if (SDreadattr(s2r->sd_id, attr_index, &s2r->mva) == FAIL) {
		sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
		Error(message);
		return(-1);
	}


	/* SPCOVER */   
	strcpy(attr_name, SPCOVER);
	if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
		sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
		Error(message);
		return (-1);
	}
	if (SDreadattr(s2r->sd_id, attr_index, &s2r->spcover) == FAIL) {
		sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
		Error(message);
		return(-1);
	}

	/* CLCOVER */   
	strcpy(attr_name, CLCOVER);
	if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
		sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
		Error(message);
		return (-1);
	}
	if (SDreadattr(s2r->sd_id, attr_index, &s2r->clcover) == FAIL) {
		sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
		Error(message);
		return(-1);
	}

	/* ACCODE.  11/21/17 */
	strcpy(attr_name, ACCODE);
	if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
		sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
		Error(message);
		return (-1);
	}
	if (SDattrinfo(s2r->sd_id, attr_index, attr_name, &data_type, &count) == FAIL) {
		Error("Error in SDattrinfo");
		return(-1);
	}
	if (SDreadattr(s2r->sd_id, attr_index, s2r->accode) == FAIL) {
		sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
		Error(message);
		return(-1);
	}
	s2r->accode[count] = '\0';  /* Forgot to add \0. Fixed on Jul 26, 2019. 
				       But not a problem in v1.4?  It was a bug: v1.4 metadata contains garbage.*/



	/* Dec 26, 2016: If the AROP metadata are available, read them. They are not available
	 * before post processing.
 	 * Check on S_AROP_REFIMG to tell if they are available. 
	 */
	/* AROP REFIMG */
	strcpy(attr_name, S_AROP_REFIMG);
	if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
		strcpy(s2r->refimg, "NONE");
		s2r->ncp = 0;
		s2r->rmse = 0;
		s2r->xshift = 0;
		s2r->yshift = 0;
	}
	else { 
		if (SDreadattr(s2r->sd_id, attr_index, s2r->refimg) == FAIL) {
			sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
			Error(message);
			return(-1);
		}
		if (SDattrinfo(s2r->sd_id, attr_index, attr_name, &data_type, &count) == FAIL) {
			Error("Error in SDattrinfo");
			return(-1);
		}
		s2r->refimg[count] = '\0';

		/* AROP NCP */
		strcpy(attr_name, S_AROP_NCP);
		if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
			sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
			Error(message);
			return (-1);
		}
		if (SDreadattr(s2r->sd_id, attr_index, &s2r->ncp) == FAIL) {
			sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
			Error(message);
			return(-1);
		}

		/* AROP RMSE */
		strcpy(attr_name, S_AROP_RMSE);
		if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
			sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
			Error(message);
			return (-1);
		}
		if (SDreadattr(s2r->sd_id, attr_index, &s2r->rmse) == FAIL) {
			sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
			Error(message);
			return(-1);
		}

		/* AROP shiftx */
		strcpy(attr_name, S_AROP_XSHIFT);
		if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
			sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
			Error(message);
			return (-1);
		}
		if (SDreadattr(s2r->sd_id, attr_index, &s2r->xshift) == FAIL) {
			sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
			Error(message);
			return(-1);
		}

		/* AROP shifty */
		strcpy(attr_name, S_AROP_YSHIFT);
		if ((attr_index = SDfindattr(s2r->sd_id, attr_name)) == FAIL) {
			sprintf(message, "Attribute \"%s\" not found in %s", attr_name, s2r->fname);
			Error(message);
			return (-1);
		}
		if (SDreadattr(s2r->sd_id, attr_index, &s2r->yshift) == FAIL) {
			sprintf(message, "Error read attribute \"%s\" in %s", attr_name, s2r->fname);
			Error(message);
			return(-1);
		}
	}

	return(0);
}
